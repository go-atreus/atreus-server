package dict

import (
	context "context"
	fmt "fmt"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	gorm "gorm.io/gorm"
)

type SysDictORM struct {
	Code      string
	CreatedAt string
	Deleted   string
	HashCode  string
	Id        int32 `gorm:"primaryKey;autoIncrement"`
	Remarks   string
	Status    int32
	Title     string
	UpdatedAt string
	ValueType int32
}

// TableName overrides the default tablename generated by GORM
func (SysDictORM) TableName() string {
	return "sys_dicts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *SysDict) ToORM(ctx context.Context) (SysDictORM, error) {
	to := SysDictORM{}
	var err error
	if prehook, ok := interface{}(m).(SysDictWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Code = m.Code
	to.Title = m.Title
	to.HashCode = m.HashCode
	to.Remarks = m.Remarks
	to.Status = m.Status
	to.ValueType = m.ValueType
	to.Deleted = m.Deleted
	to.CreatedAt = m.CreatedAt
	to.UpdatedAt = m.UpdatedAt
	if posthook, ok := interface{}(m).(SysDictWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *SysDictORM) ToPB(ctx context.Context) (SysDict, error) {
	to := SysDict{}
	var err error
	if prehook, ok := interface{}(m).(SysDictWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Code = m.Code
	to.Title = m.Title
	to.HashCode = m.HashCode
	to.Remarks = m.Remarks
	to.Status = m.Status
	to.ValueType = m.ValueType
	to.Deleted = m.Deleted
	to.CreatedAt = m.CreatedAt
	to.UpdatedAt = m.UpdatedAt
	if posthook, ok := interface{}(m).(SysDictWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type SysDict the arg will be the target, the caller the one being converted from

// SysDictBeforeToORM called before default ToORM code
type SysDictWithBeforeToORM interface {
	BeforeToORM(context.Context, *SysDictORM) error
}

// SysDictAfterToORM called after default ToORM code
type SysDictWithAfterToORM interface {
	AfterToORM(context.Context, *SysDictORM) error
}

// SysDictBeforeToPB called before default ToPB code
type SysDictWithBeforeToPB interface {
	BeforeToPB(context.Context, *SysDict) error
}

// SysDictAfterToPB called after default ToPB code
type SysDictWithAfterToPB interface {
	AfterToPB(context.Context, *SysDict) error
}

// DefaultCreateSysDict executes a basic gorm create call
func DefaultCreateSysDict(ctx context.Context, in *SysDict, db *gorm.DB) (*SysDict, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SysDictORMWithBeforeCreate_); ok {
		if ormObj, db, err = hook.BeforeCreate_(ctx, db, ormObj); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SysDictORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type SysDictORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB, SysDictORM) (SysDictORM, *gorm.DB, error)
}
type SysDictORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadSysDict(ctx context.Context, in *SysDict, db *gorm.DB) (*SysDict, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SysDictORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(SysDictORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := SysDictORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(SysDictORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type SysDictORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SysDictORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SysDictORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteSysDict(ctx context.Context, in *SysDict, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SysDictORMWithBeforeDelete_); ok {
		if ormObj, db, err = hook.BeforeDelete_(ctx, db, ormObj); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&SysDictORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(SysDictORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type SysDictORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB, SysDictORM) (SysDictORM, *gorm.DB, error)
}
type SysDictORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteSysDictSet(ctx context.Context, in []*SysDict, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&SysDictORM{})).(SysDictORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&SysDictORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&SysDictORM{})).(SysDictORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type SysDictORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*SysDict, *gorm.DB) (*gorm.DB, error)
}
type SysDictORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*SysDict, *gorm.DB) error
}

// DefaultStrictUpdateSysDict clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateSysDict(ctx context.Context, in *SysDict, db *gorm.DB) (*SysDict, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateSysDict")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &SysDictORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(SysDictORMWithBeforeStrictUpdateCleanup); ok {
		if ormObj, db, err = hook.BeforeStrictUpdateCleanup(ctx, db, ormObj); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(SysDictORMWithBeforeStrictUpdateSave); ok {
		if ormObj, db, err = hook.BeforeStrictUpdateSave(ctx, db, ormObj); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SysDictORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type SysDictORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB, SysDictORM) (SysDictORM, *gorm.DB, error)
}
type SysDictORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB, SysDictORM) (SysDictORM, *gorm.DB, error)
}
type SysDictORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchSysDict executes a basic gorm update call with patch behavior
func DefaultPatchSysDict(ctx context.Context, in *SysDict, updateMask *field_mask.FieldMask, db *gorm.DB) (*SysDict, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj SysDict
	var err error
	if hook, ok := interface{}(&pbObj).(SysDictWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadSysDict(ctx, &SysDict{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(SysDictWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskSysDict(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(SysDictWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateSysDict(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(SysDictWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type SysDictWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *SysDict, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SysDictWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *SysDict, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SysDictWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *SysDict, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SysDictWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *SysDict, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetSysDict executes a bulk gorm update call with patch behavior
func DefaultPatchSetSysDict(ctx context.Context, objects []*SysDict, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*SysDict, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*SysDict, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchSysDict(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskSysDict patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskSysDict(ctx context.Context, patchee *SysDict, patcher *SysDict, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*SysDict, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Code" {
			patchee.Code = patcher.Code
			continue
		}
		if f == prefix+"Title" {
			patchee.Title = patcher.Title
			continue
		}
		if f == prefix+"HashCode" {
			patchee.HashCode = patcher.HashCode
			continue
		}
		if f == prefix+"Remarks" {
			patchee.Remarks = patcher.Remarks
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"ValueType" {
			patchee.ValueType = patcher.ValueType
			continue
		}
		if f == prefix+"Deleted" {
			patchee.Deleted = patcher.Deleted
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListSysDict executes a gorm list call
func DefaultListSysDict(ctx context.Context, db *gorm.DB) ([]*SysDict, error) {
	in := SysDict{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SysDictORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(SysDictORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []SysDictORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SysDictORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*SysDict{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type SysDictORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SysDictORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SysDictORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]SysDictORM) error
}
type DictDefaultServer struct {
	DB *gorm.DB
}

// DictData ...
func (m *DictDefaultServer) DictData(ctx context.Context, in *DictDataReq) (*DictDataResp, error) {
	out := &DictDataResp{}
	return out, nil
}

// DictValidHash ...
func (m *DictDefaultServer) DictValidHash(ctx context.Context, in *emptypb.Empty) (*ValidHashResp, error) {
	out := &ValidHashResp{}
	return out, nil
}

// Create ...
func (m *DictDefaultServer) Create(ctx context.Context, in *SysDict) (*SysDict, error) {
	db := m.DB
	if custom, ok := interface{}(in).(DictSysDictWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateSysDict(ctx, in, db)
	if err != nil {
		return nil, err
	}
	out := res
	if custom, ok := interface{}(in).(DictSysDictWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// DictSysDictWithBeforeCreate called before DefaultCreateSysDict in the default Create handler
type DictSysDictWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm.DB) (*gorm.DB, error)
}

// DictSysDictWithAfterCreate called before DefaultCreateSysDict in the default Create handler
type DictSysDictWithAfterCreate interface {
	AfterCreate(context.Context, *SysDict, *gorm.DB) error
}

// Update ...
func (m *DictDefaultServer) Update(ctx context.Context, in *SysDict) (*SysDict, error) {
	out := &SysDict{}
	return out, nil
}

// Delete ...
func (m *DictDefaultServer) Delete(ctx context.Context, in *SysDict) (*SysDict, error) {
	out := &SysDict{}
	return out, nil
}

// Get ...
func (m *DictDefaultServer) Get(ctx context.Context, in *SysDict) (*SysDict, error) {
	out := &SysDict{}
	return out, nil
}

// List ...
func (m *DictDefaultServer) List(ctx context.Context, in *SysDict) (*ListSysDictResp, error) {
	db := m.DB
	if custom, ok := interface{}(in).(DictSysDictWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListSysDict(ctx, db)
	if err != nil {
		return nil, err
	}
	out := &ListSysDictResp{Results: res}
	if custom, ok := interface{}(in).(DictSysDictWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// DictSysDictWithBeforeList called before DefaultListSysDict in the default List handler
type DictSysDictWithBeforeList interface {
	BeforeList(context.Context, *gorm.DB) (*gorm.DB, error)
}

// DictSysDictWithAfterList called before DefaultListSysDict in the default List handler
type DictSysDictWithAfterList interface {
	AfterList(context.Context, *ListSysDictResp, *gorm.DB) error
}
